# JVM

- Classic VM
- Exact VM
- HotSpot VM
  JDK1.3开始成为成为默认虚拟机。其他两个商用虚拟机都没有方法区（Method Area）的概念。
  HotSpot指的是它的热点代码探测技术。
  - 通过计数器找到最具编译价值代码，触发即时编译或栈上替换。
  - 通过编译器与解释器协同工作， 在最优化的程序响应时间与最佳执行性能中取得平衡。
- JRocket VM
  专注于服务器端应用。
  不太关注程序启动速度，所以没有解释器。
- J9 VM
- Graal VM

# 内存结构概述

### 虚拟机架构简图

<img src="E:\学习笔记\imgs\JVM架构.png"  />

### 虚拟机详细架构

<img src="E:\学习笔记\imgs\JVM架构详细.png" style="zoom: 80%;" />



# 类加载器子系统 ClassLoader Subsystem

类加载器子系统负责读取class文件， 要求class文件具有文件表示（CAFEBABE）。
加载的类信息存放在名为方法区的内存空间里。 除了类的信息外， 方法区中还会存放运行时常量池信息， 可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。

类加载器三步

- 加载Loading
- 链接Linking
- 初始化Initialization

## 加载 Loading

1. 通过一个类的全限定名（包名+类名？）获取定义此类的二进制字节流。
2. 将这个字节流所代表的的静态数据结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。

## 链接 Linking

链接也有三步

- 验证 Verify

  - 目的在于确保class文件字节流中包含信息符合当前虚拟机要求， 保证被加载类的正确性， 不会危害虚拟机的安全。
  - 主要包括四种验证， 文件格式验证，元数据验证， 字节码验证， 符号引用验证。

- 准备 Prepare

  - 为类变量分配内存并且设置该类变量的默认初始值，即零值。（在初始化时才会赋给实际值）
  - 这里不包含用final修饰的static， 因为final在编译时就会分配实际值， 准备阶段会显式初始化。
  - 这里不会为实例变量分配初始化， 类变量会分配在方法区中， 而实例变量是会随着对象一起分配到Java堆中。
  - 成员变量：在类内定义的变量； 实例变量：没用static修饰的成员变量； 类变量：用static修饰的成员变量。

- 解析 Resolve

  - 将常量池内的符号引用转换为直接引用的过程。

  - 解析操作往往会伴随着JVM在执行完初始化后再执行。

  - 符号引用： 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在[Java](http://lib.csdn.net/base/javaee)中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

  - 直接引用：  直接引用可以是

    （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

    （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

    （3）一个能间接定位到目标的句柄

    直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

  - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

## 初始化 Initalization

- 初始化阶段就是执行类构造器方法<clinit>的过程。
- 此方法不需要定义， 是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
- 构造器方法中指令按照在源文件中出现的顺序执行。
- <clinit>方法不同于类的构造器方法。（关联：构造器是虚拟机视角下的<init>()）。
- 若该类有父类， JVM会保证在子类的<clinit>执行前， 父类的<clinit>会先执行完毕。
- JVM必须保证一个类的<clinit>方法在多线程下被同步加锁。



## 类加载器的分类

- 启动类加载器 Bootstrap ClassLoader
  - 由C/C++实现， 嵌套在JVM内部
  - 用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）， 用于提供JVM自身需要的类
  - 并不继承java.lang.ClassLoader， 没有父加载器
  - 加载扩展类和应用类加载器， 并指定为他们的父类加载器
  - 处于安全考虑， Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
- 扩展类加载器 Extendsion ClassLoader
  - Java语言编写, 派生于ClassLoader类
  - 父类加载器为启动类加载器
  - 从java.ext.dirs系统属性所指定的目录中加载类库， 或从JDK的安装目录的jre/lib/ext子目录下加载类库。 如果用户创建的jar放在此目录下， 也会自动有扩展类加载器加载。
- 应用类加载器 AppClassLoader
  - Java语言编写, 派生于ClassLoader类
  - 父类加载器为扩展类加载器
  - 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
  - 是程序默认的类加载器， 一般来说， Java应用的类都是由它来完成加载。
  - 通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器。
- 用户自定义加载器
  - 隔离加载， tomcat的WebappClassLoader， 保证不同应用之间的类不会冲突
  - 修改类加载的方式
  - 扩展加载源
  - 保证源码安全， 防止源码泄露， 给字节码加密
  - 通过继承java.lang.ClassLoader类的方式， 实现自己的类加载器。
  - 在JDK1.2之前， 需要重写loadClass()方法； 在1.2之后，建议把自定义的类加载逻辑放在findClass()方法中
  - 如果没有太过于复杂的需求， 可以直接继承URLClassLoader类， 这样可以避免自己去编写findClass方法及获取其字节码流的方式， 使自定义类加载器的编写更加简洁

## 双亲委派机制

Java虚拟机对class文件采用的是**按需加载**的方式， 也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时， Java虚拟机采用的是**双亲委派机制**， 即把请求交给父类处理， 它是一种任务委派模式（责任链模式）。

### 工作原理：

-  如果一个类加载器收到类加载请求， 它并不会自己先去加载， 而是把这个请求委托给父加载器去执行；

-  如果父类加载器还存在父类加载器， 则进一步向上委托， 依次递归， 请求最终将达到顶层的启动类加载器；

-  如果父类加载器可以完成类加载任务， 就成功返回， 若父类加载器无法完成加载任务， 子加载器才会尝试自己去加载， 这就是双亲委派模式。

#### 双亲委派模式的优势：

- 1） 避免了类的重复加载。
- 2） 保护程序安全， 防止核心API被篡改。



## 其他

- 在JVM中判断两个class对象是否为同一个类存在两个必要条件：

  - 类的完整类名必须一致， 包括包名，即全限定名。

  - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。

- JVM必须知道一个类型是由启动类加载器还是用户类加载器加载的。 如果一个类型是由用户类加载器加载的， 那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存到**方法区**中。 当解析一个类型到另一个类型的引用的时候， JVM需保证这两个类型的类加载器是相同的。
- Java程序对类的使用方式为两种： 主动使用和被动使用。
  - 主动使用分为七种情况：
    - 创建类的实例
    - 访问某个类或接口的静态变量， 或者对该静态变量赋值
    - 调用类的静态方法
    - 反射（比如Class.forName("java.lang.String")
    - 初始化一个类的子类
    - Java虚拟机启动时被表明为启动类的类
    - JDK7开始提供的动态语言支持： java.lang.invoke.MethodHandler实例的解析结果，REF_getstatic、REF_putstatic、REF_invokeStatic句柄对应的类没有初始化， 则初始化
  - 除了以上七种请阔， 其他使用Java类的方式都被看作是对类的被动使用， 都不会导致类的初始化。



# 运行时数据区（Runtime Data Area）

![](E:\学习笔记\imgs\rda.jpg)

![](E:\学习笔记\imgs\rda detail.png)

### 线程

- 线程是一个程序里的运行单元。 JVM允许一个应用有多个线程并行的执行。
- 在Hotspot JVM里， 每个线程都与操作系统的本地线程直接映射。
  - 当一个Java线程准备好执行以后， 此时一个操作系统的本地线程也同时创建。 当Java线程执行终止以后， 本地线程也会回收。
- 操作系统负责所有线程安排调度到任何一个可用的CPU上。 一旦本地线程初始化成功， 他就会调用Java线程中的run方法。
- 如果你使用jconsole或者其他调试工具， 都能看到在后台有许多线程在运行。 这些**后台线程**不包括调用public static void main(String[])的main线程以及所有main线程自己创建的线程。
- 这些主要的后台系统线程包括：
  - **虚拟机线程**：这种线程的操作需要JVM达到安全点才会出现。 这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点， 这样堆才不会变化。 这种线程的执行类型包括“stop-the-world”的垃圾收集， 线程栈收集， 线程挂起以及偏向锁撤销。
  - **周期任务线程**：这种线程是时间周期时间的体现（比如中断）， 他们一般用于周期性操作的调度执行。
  - **GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。
  - **编译线程**：这种线程在运行时会将字节码编译成本地代码。
  - **信号调度线程**： 这种线程接受信号并发送给JVM， 在它内部通过调用适当的方法进行处理。



### PC寄存器/程序计数器（Program Counter Register)

JVM中的程序计数寄存器（Program Counter Register）中， Register的命名源于CPU的寄存器（CPU Register）， 寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器中才能够运行。

这里， 并非是广义上所指的物理寄存器， 或许将其翻译为PC计数器（或指令计数器）会更加贴切（也成为程序钩子）， 并且也不容易引起一些不必要的误会。 **JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。**

- **作用**： PC寄存器是用来存储指向下一条指令的地址， 即将要执行的指令代码。 由执行引擎读取下一条指令。
- 它是一块很小的内存空间， 几乎可以忽略不计。 也是运行速度最快的存储空间。
- 在JVM规范中， 每个线程都有它自己的程序计数器， 是线程私有的， 生命周期和线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行， 也就是所谓的当前方法。 程序计数器会存储当前线程正在执行的Java方法的JVM指令地址； 或者， 如果是在执行native方法， 则是未指定值（undefined）。
- 它是程序控制流的指示器， 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。



### 虚拟机栈

#### 虚拟机栈概述

- Java虚拟机栈， 早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈， 其内部保存一个个的栈帧， 对应着一次次的Java方法调用。
- 是线程私有的。
- 生命周期与线程的生命周期一致。
- 主管Java程序的运行， 它保存方法的局部变量、部分结果， 并参与方法的调用和返回。
- 栈的特点（优点）：
  - 栈是一种快速有效的分配存储方式， 访问速度仅次于PC寄存器（程序计数器）。
  - JVM直接对栈的操作只有两个：
    - 每个方法执行， 伴随着进栈
    - 执行结束后的出栈工作
  - 对于栈来说不存在垃圾回收问题
- Java 虚拟机规范允许Java栈的大小是动态的或者是固定的。
  - 如果采用固定大小的虚拟机栈， 那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量， Java虚拟机将会抛出一个StackOverFlowError异常。
  - 如果Java虚拟机栈的容量可以动态扩展， 并且在尝试扩展的时候无法申请到足够的内存， 或者在创建新的线程的时候没有足够的内存区创建对应的虚拟机栈， 则会抛出一个OutOfMemoryError异常。
- 通过**-Xss**可以设置Java虚拟机栈的大小


#### 栈运行原理

- JVM直接对Java栈的操作只有两个， 就是对栈帧的压栈和出栈， 遵循FILO原则。
- 在一条活动线程中， 一个时间点上， 只会有一个活动的栈帧。 即只有当前正在执行的方法的栈帧（栈顶栈帧）时有效的， 这个栈帧被称为当前栈帧， 与当前栈帧对应的方法就是当前方法， 定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法， 对应的新的栈帧会被创建出来， 放在栈的顶端， 成为新的当前帧。
- **思考**： PC寄存器在当前栈帧出栈之后， 如何知晓下一栈帧的指令地址从哪里开始？  （当前栈帧的返回地址？）
- 不同线程中所包含的栈帧时不允许存在互相引用的。
- 如果当前方法m1调用了其他方法m2， 方法m2返回之际， 当前栈帧m2会传回此方法m2的执行结果给前一个栈帧m1， 接着，虚拟机会丢弃当前栈帧m2， 使得前一个栈帧m1重新成为当前栈帧。
- Java有两种返回函数的方式， 一种是正常的函数返回， 使用return指令； 另一种是抛出异常。 不管使用哪种方式， 都会导致栈帧被弹出。



#### 栈帧的内部结构

栈帧内存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）（或表达式）
- 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
- 方法返回地址（Return Address）（或方法正常退出或异常退出的定义）
- 一些附加信息

##### 局部变量表

- 局部变量表也被称为局部变量数组或本地变量表。
- 定义为一个数字数组， 主要用于存储方法参数和定义在方法体内的局部变量， 这些数据包括基本数据类型， 对象引用（reference），以及returnAddress等。
- 由于局部变量表是建立在线程的栈上， 是线程的私有数据， 因此不存在数据安全问题。
- 局部变量表所需的容量大小是在编译期确定下来的， 并保存在方法的Code属性的maximun_local_variables数据项中。 在方法运行期间是不会改变局部变量表的大小的。
- 参数值的存放总是在局部变量数组的index0开始， 到数组长度-1的索引结束。
- 局部变量表的基本存储单元是Slot(变量槽)。
- 在局部变量表里， 32位以内的类型只占用一个Slot（包括returnAddress类型）， 64位类型占用两个Slot（long和double）。
- 方法嵌套调用的次数由栈的大小决定的。
- 局部变量表中的变量旨在当前方法调用中有效。在方法执行时， 虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后， 随着方法栈帧的销毁， 局部变量表也会随之销毁。

###### Slot

- JVM会为局部变量表的每一个Slot分配一个访问索引， 通过这个索引即可成功访问到局部变量表中指定的局部变量值。
- 当一个实例方法被调用的时候， 它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上。
- 如果需要访问局部变量表中的一个64bit的局部变量值时， 只需要访问前一个索引即可。
- 如果当前帧时有构造方法或者实例方法创建的， 那么该对象应用this将会存放在index为0的Slot处， 其余参数按照参数表顺序继续排列。静态方法不能使用this对象， 静态方法的局部变量表中没有this对象。
- 局部变量表的Slot是可以重用的， 如果一个局部变量过了他的作用域， 那么在其作用域之后申明的新的局部变量就很可能会复用过期局部变量的槽位， 从而达到节省资源的目的。



