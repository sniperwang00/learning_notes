# JVM

- Classic VM
- Exact VM
- HotSpot VM
  JDK1.3开始成为成为默认虚拟机。其他两个商用虚拟机都没有方法区（Method Area）的概念。
  HotSpot指的是它的热点代码探测技术。
  - 通过计数器找到最具编译价值代码，触发即时编译或栈上替换。
  - 通过编译器与解释器协同工作， 在最优化的程序响应时间与最佳执行性能中取得平衡。
- JRocket VM
  专注于服务器端应用。
  不太关注程序启动速度，所以没有解释器。
- J9 VM
- Graal VM

# 内存结构概述

### 虚拟机架构简图

<img src="E:\学习笔记\imgs\JVM架构.png"  />

### 虚拟机详细架构

<img src="E:\学习笔记\imgs\JVM架构详细.png" style="zoom: 80%;" />



# 类加载器子系统 ClassLoader Subsystem

类加载器子系统负责读取class文件， 要求class文件具有文件表示（CAFEBABE）。
加载的类信息存放在名为方法区的内存空间里。 除了类的信息外， 方法区中还会存放运行时常量池信息， 可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。

类加载器三步

- 加载Loading
- 链接Linking
- 初始化Initialization

## 加载 Loading

1. 通过一个类的全限定名（包名+类名？）获取定义此类的二进制字节流。
2. 将这个字节流所代表的的静态数据结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口。

## 链接 Linking

链接也有三步

- 验证 Verify

  - 目的在于确保class文件字节流中包含信息符合当前虚拟机要求， 保证被加载类的正确性， 不会危害虚拟机的安全。
  - 主要包括四种验证， 文件格式验证，元数据验证， 字节码验证， 符号引用验证。

- 准备 Prepare

  - 为类变量分配内存并且设置该类变量的默认初始值，即零值。（在初始化时才会赋给实际值）
  - 这里不包含用final修饰的static， 因为final在编译时就会分配实际值， 准备阶段会显式初始化。
  - 这里不会为实例变量分配初始化， 类变量会分配在方法区中， 而实例变量是会随着对象一起分配到Java堆中。
  - 成员变量：在类内定义的变量； 实例变量：没用static修饰的成员变量； 类变量：用static修饰的成员变量。

- 解析 Resolve

  - 将常量池内的符号引用转换为直接引用的过程。

  - 解析操作往往会伴随着JVM在执行完初始化后再执行。

  - 符号引用： 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在[Java](http://lib.csdn.net/base/javaee)中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

  - 直接引用：  直接引用可以是

    （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

    （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

    （3）一个能间接定位到目标的句柄

    直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

  - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

## 初始化 Initalization

- 初始化阶段就是执行类构造器方法<clinit>的过程。
- 此方法不需要定义， 是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
- 构造器方法中指令按照在源文件中出现的顺序执行。
- <clinit>方法不同于类的构造器方法。（关联：构造器是虚拟机视角下的<init>()）。
- 若该类有父类， JVM会保证在子类的<clinit>执行前， 父类的<clinit>会先执行完毕。
- JVM必须保证一个类的<clinit>方法在多线程下被同步加锁。



## 类加载器的分类

- 启动类加载器 Bootstrap ClassLoader
  - 由C/C++实现， 嵌套在JVM内部
  - 用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）， 用于提供JVM自身需要的类
  - 并不继承java.lang.ClassLoader， 没有父加载器
  - 加载扩展类和应用类加载器， 并指定为他们的父类加载器
  - 处于安全考虑， Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
- 扩展类加载器 Extendsion ClassLoader
  - Java语言编写, 派生于ClassLoader类
  - 父类加载器为启动类加载器
  - 从java.ext.dirs系统属性所指定的目录中加载类库， 或从JDK的安装目录的jre/lib/ext子目录下加载类库。 如果用户创建的jar放在此目录下， 也会自动有扩展类加载器加载。
- 应用类加载器 AppClassLoader
  - Java语言编写, 派生于ClassLoader类
  - 父类加载器为扩展类加载器
  - 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
  - 是程序默认的类加载器， 一般来说， Java应用的类都是由它来完成加载。
  - 通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器。
- 用户自定义加载器
  - 隔离加载， tomcat的WebappClassLoader， 保证不同应用之间的类不会冲突
  - 修改类加载的方式
  - 扩展加载源
  - 保证源码安全， 防止源码泄露， 给字节码加密
  - 通过继承java.lang.ClassLoader类的方式， 实现自己的类加载器。
  - 在JDK1.2之前， 需要重写loadClass()方法； 在1.2之后，建议把自定义的类加载逻辑放在findClass()方法中
  - 如果没有太过于复杂的需求， 可以直接继承URLClassLoader类， 这样可以避免自己去编写findClass方法及获取其字节码流的方式， 使自定义类加载器的编写更加简洁

## 双亲委派机制

Java虚拟机对class文件采用的是**按需加载**的方式， 也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时， Java虚拟机采用的是**双亲委派机制**， 即把请求交给父类处理， 它是一种任务委派模式（责任链模式）。

### 工作原理：

-  如果一个类加载器收到类加载请求， 它并不会自己先去加载， 而是把这个请求委托给父加载器去执行；

-  如果父类加载器还存在父类加载器， 则进一步向上委托， 依次递归， 请求最终将达到顶层的启动类加载器；

-  如果父类加载器可以完成类加载任务， 就成功返回， 若父类加载器无法完成加载任务， 子加载器才会尝试自己去加载， 这就是双亲委派模式。

#### 双亲委派模式的优势：

- 1） 避免了类的重复加载。
- 2） 保护程序安全， 防止核心API被篡改。



## 其他

- 在JVM中判断两个class对象是否为同一个类存在两个必要条件：

  - 类的完整类名必须一致， 包括包名，即全限定名。

  - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。

- JVM必须知道一个类型是由启动类加载器还是用户类加载器加载的。 如果一个类型是由用户类加载器加载的， 那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存到**方法区**中。 当解析一个类型到另一个类型的引用的时候， JVM需保证这两个类型的类加载器是相同的。
- Java程序对类的使用方式为两种： 主动使用和被动使用。
  - 主动使用分为七种情况：
    - 创建类的实例
    - 访问某个类或接口的静态变量， 或者对该静态变量赋值
    - 调用类的静态方法
    - 反射（比如Class.forName("java.lang.String")
    - 初始化一个类的子类
    - Java虚拟机启动时被表明为启动类的类
    - JDK7开始提供的动态语言支持： java.lang.invoke.MethodHandler实例的解析结果，REF_getstatic、REF_putstatic、REF_invokeStatic句柄对应的类没有初始化， 则初始化
  - 除了以上七种请阔， 其他使用Java类的方式都被看作是对类的被动使用， 都不会导致类的初始化。



# 运行时数据区（Runtime Data Area）

![](E:\学习笔记\imgs\rda.jpg)

![](E:\学习笔记\imgs\rda detail.png)

### 线程

- 线程是一个程序里的运行单元。 JVM允许一个应用有多个线程并行的执行。
- 在Hotspot JVM里， 每个线程都与操作系统的本地线程直接映射。
  - 当一个Java线程准备好执行以后， 此时一个操作系统的本地线程也同时创建。 当Java线程执行终止以后， 本地线程也会回收。
- 操作系统负责所有线程安排调度到任何一个可用的CPU上。 一旦本地线程初始化成功， 他就会调用Java线程中的run方法。
- 如果你使用jconsole或者其他调试工具， 都能看到在后台有许多线程在运行。 这些**后台线程**不包括调用public static void main(String[])的main线程以及所有main线程自己创建的线程。
- 这些主要的后台系统线程包括：
  - **虚拟机线程**：这种线程的操作需要JVM达到安全点才会出现。 这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点， 这样堆才不会变化。 这种线程的执行类型包括“stop-the-world”的垃圾收集， 线程栈收集， 线程挂起以及偏向锁撤销。
  - **周期任务线程**：这种线程是时间周期时间的体现（比如中断）， 他们一般用于周期性操作的调度执行。
  - **GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。
  - **编译线程**：这种线程在运行时会将字节码编译成本地代码。
  - **信号调度线程**： 这种线程接受信号并发送给JVM， 在它内部通过调用适当的方法进行处理。



### PC寄存器/程序计数器（Program Counter Register)

JVM中的程序计数寄存器（Program Counter Register）中， Register的命名源于CPU的寄存器（CPU Register）， 寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器中才能够运行。

这里， 并非是广义上所指的物理寄存器， 或许将其翻译为PC计数器（或指令计数器）会更加贴切（也成为程序钩子）， 并且也不容易引起一些不必要的误会。 **JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。**

- **作用**： PC寄存器是用来存储指向下一条指令的地址， 即将要执行的指令代码。 由执行引擎读取下一条指令。
- 它是一块很小的内存空间， 几乎可以忽略不计。 也是运行速度最快的存储空间。
- 在JVM规范中， 每个线程都有它自己的程序计数器， 是线程私有的， 生命周期和线程的生命周期保持一致。
- 任何时间一个线程都只有一个方法在执行， 也就是所谓的当前方法。 程序计数器会存储当前线程正在执行的Java方法的JVM指令地址； 或者， 如果是在执行native方法， 则是未指定值（undefined）。
- 它是程序控制流的指示器， 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。



### 虚拟机栈

#### 虚拟机栈概述

- Java虚拟机栈， 早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈， 其内部保存一个个的栈帧， 对应着一次次的Java方法调用。
- 是线程私有的。
- 生命周期与线程的生命周期一致。
- 主管Java程序的运行， 它保存方法的局部变量、部分结果， 并参与方法的调用和返回。
- 栈的特点（优点）：
  - 栈是一种快速有效的分配存储方式， 访问速度仅次于PC寄存器（程序计数器）。
  - JVM直接对栈的操作只有两个：
    - 每个方法执行， 伴随着进栈
    - 执行结束后的出栈工作
  - 对于栈来说不存在垃圾回收问题
- Java 虚拟机规范允许Java栈的大小是动态的或者是固定的。
  - 如果采用固定大小的虚拟机栈， 那么每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量， Java虚拟机将会抛出一个StackOverFlowError异常。
  - 如果Java虚拟机栈的容量可以动态扩展， 并且在尝试扩展的时候无法申请到足够的内存， 或者在创建新的线程的时候没有足够的内存区创建对应的虚拟机栈， 则会抛出一个OutOfMemoryError异常。
- 通过**-Xss**可以设置Java虚拟机栈的大小


#### 栈运行原理

- JVM直接对Java栈的操作只有两个， 就是对栈帧的压栈和出栈， 遵循FILO原则。
- 在一条活动线程中， 一个时间点上， 只会有一个活动的栈帧。 即只有当前正在执行的方法的栈帧（栈顶栈帧）时有效的， 这个栈帧被称为当前栈帧， 与当前栈帧对应的方法就是当前方法， 定义这个方法的类就是当前类。
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
- 如果在该方法中调用了其他方法， 对应的新的栈帧会被创建出来， 放在栈的顶端， 成为新的当前帧。
- **思考**： PC寄存器在当前栈帧出栈之后， 如何知晓下一栈帧的指令地址从哪里开始？  （当前栈帧的返回地址？）
- 不同线程中所包含的栈帧时不允许存在互相引用的。
- 如果当前方法m1调用了其他方法m2， 方法m2返回之际， 当前栈帧m2会传回此方法m2的执行结果给前一个栈帧m1， 接着，虚拟机会丢弃当前栈帧m2， 使得前一个栈帧m1重新成为当前栈帧。
- Java有两种返回函数的方式， 一种是正常的函数返回， 使用return指令； 另一种是抛出异常。 不管使用哪种方式， 都会导致栈帧被弹出。



#### 栈帧的内部结构

栈帧内存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）（或表达式）
- 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
- 方法返回地址（Return Address）（或方法正常退出或异常退出的定义）
- 一些附加信息

##### 局部变量表

- 局部变量表也被称为局部变量数组或本地变量表。
- 定义为一个数字数组， 主要用于存储方法参数和定义在方法体内的局部变量， 这些数据包括基本数据类型， 对象引用（reference），以及returnAddress等。
- 由于局部变量表是建立在线程的栈上， 是线程的私有数据， 因此不存在数据安全问题。
- 局部变量表所需的容量大小是在编译期确定下来的， 并保存在方法的Code属性的maximun_local_variables数据项中。 在方法运行期间是不会改变局部变量表的大小的。
- 参数值的存放总是在局部变量数组的index0开始， 到数组长度-1的索引结束。
- 局部变量表的基本存储单元是Slot(变量槽)。
- 在局部变量表里， 32位以内的类型只占用一个Slot（包括returnAddress类型）， 64位类型占用两个Slot（long和double）。
- 方法嵌套调用的次数由栈的大小决定的。
- 局部变量表中的变量旨在当前方法调用中有效。在方法执行时， 虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后， 随着方法栈帧的销毁， 局部变量表也会随之销毁。

###### Slot

- JVM会为局部变量表的每一个Slot分配一个访问索引， 通过这个索引即可成功访问到局部变量表中指定的局部变量值。
- 当一个实例方法被调用的时候， 它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上。
- 如果需要访问局部变量表中的一个64bit的局部变量值时， 只需要访问前一个索引即可。
- 如果当前帧时有构造方法或者实例方法创建的， 那么该对象应用this将会存放在index为0的Slot处， 其余参数按照参数表顺序继续排列。静态方法不能使用this对象， 静态方法的局部变量表中没有this对象。
- 局部变量表的Slot是可以重用的， 如果一个局部变量过了他的作用域， 那么在其作用域之后申明的新的局部变量就很可能会复用过期局部变量的槽位， 从而达到节省资源的目的。

##### 操作数栈

操作数栈， 在方法执行过程中， 根据字节码指令往栈中写入数据或提取数据， 即入栈/出栈。

- 某些字节码指令将值压入操作数栈， 其余的字节码指令将操作数取出栈。 使用它们后再把结果压入栈。
- 比如：执行复制、交换、求和等操作。

- 操作数栈主要用于保存计算过程的中间结果， 同时作为计算过程中变量临时的存储空间。
- 操作数栈就是JVM执行引擎的一个工作区， 当一个方法刚开始执行的时候， 一个新的栈帧也会随之创建， 这个方法的操作数栈是空的。
- 每一个操作数栈都会拥有一个明确的栈深度（大小）用于存储数值（数组实现， 创建时指定大小）， 其所需的最大深度在编译期就定义好了， 保存在方法的Code属性中， 为max_stack的值。
- 栈中的任何一个元素都可以是任意的Java数据类型。
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 如果被调用的方法带有返回值的话， 其返回值将会被压入当前栈帧的操作数栈中， 并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中元素的类型必须与字节码指令的序列严格匹配， 这有编译器在编译期间进行验证， 同时在类加载过程中的类校验阶段的数据流分析阶段药再次验证。
- Java虚拟机的解释引擎是基于栈的执行引擎， 其中的栈指的就是操作数栈。

##### 动态链接（指向运行时常量池的方法引用）

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用， 包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。 比如invokedynamic指令。
- 在Java源文件被编译到字节码文件中时， 所有的变量和方法引用都作为符号引号（Symbolic Reference）保存在class文件的常量池中。 比如： 描述一个方法调用了其他方法时， 就是通过常量池中指向方法的符号引用来表示的， 那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

###### 方法的调用

在JVM中， 将符号引号转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接： 当一个字节码文件被装载进JVM内部时， 如果被**被调用的目标方法在编译器可知， 且运行期保持不变时**， 这种情况下将调用方法的符号引号转换为直接引用的过程称之为静态链接。
- 动态链接： 如果**被调用的方法在编译期间无法确定下来**， 也就是说， 只能够在程序运行期间将调用方法的符号引用转换为直接引用， 由于这种引用转换过程具备动态性， 因此也就成为**动态引用**。

对应的方法的绑定机制为早期绑定和晚期绑定。 **绑定**是一个字段、方法或者类在符号引用被替换为直接引用的过程， 这仅仅发生一次。

- 早期绑定（Early Binding）： 早期绑定就是指被调用的目标方法**如果在编译器可知， 且运行期保持不变时**， 即可将这个方法与所属的类型进行绑定， 因此也就可以使用静态链接的方式将符号引用转换为直接引用。
- 晚期绑定（Late Binding) :  如果**被调用的方法在编译期无法被确定下来， 只能够根据运行期实际的类型绑定相关的方法**， 这种绑定方式也称之为晚期绑定。

像Java一样的面向对象的语言都有一个共性， 就是支持封装、继承、多态等面向对象特性， 自然也就具备早期绑定和晚期绑定两种绑定方式。

Java中任何一个普通的方法其实都具有虚函数的特征， 他们相当于C++语言中的虚函数（c++中用关键字virtual显示定义）。 如果Java中不希望某个方法拥有虚函数的特征， 则可以使用关键字final来标记这个方法。

- 非虚方法： 如果方法在编译期间就确定了具体的调用版本， 这个版本在运行时是不可变的。 这样的方法称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他的方法称为虚方法。

虚拟机中提供了以下几条方法调用指令：

- invokestatic： 调用静态方法
- invokespecial：调用<init>方法、私有及父类方法， 解析阶段确定唯一方法版本
- invokevirtual：调用所有虚方法
- invokeinterface：调用接口的实现方法

动态调用指令

- invokedynamic：动态解析出需要调用的方法， 然后执行

前四条指令固化在虚拟机内部， 方法的调用执行不可人为干预， 而invokedynamic指令则支持由用户确定方法版本。 **final修饰的方法是非虚方法， 但是调用指令是invokevirtual**。

- 方法重写的本质：

  1. 找到操作数栈顶的第一个元素所执行的对象的实际类型， 记作C。

  2. 如果在类型C中找到与常量中的描述符合简单名称都相符的方法， 则进行访问权限校验， 如果通过则返回这个方法的直接调用， 否则返回java.lang.IllegalAccessError异常。

  3. 否则， 按照继承关系由下向上一次对C的各个父类进行第二步的搜索和验证过程。
  4. 如果始终没有找到合适的方法， 则跑出java.lang.AbstractMethodError异常。
- 在面向对象的过程中， 会经常用到动态分派， 为了提高效率， 避免每次都重新在类的方法元数据中搜索合适的目标方法， JVM采用在类的方法区建立一个虚方法表来实现。使用索引表来代替查找。
- 每个类中都有一个虚方法表， 表中存放着各个方法的实际入口（非虚方法不存放在表中）。
- 虚方法表会在类加载的链接阶段被创建冰开始初始化， 类的初始变量值准备完成后，  JVM会把该类的方法表也初始化完毕。

##### 方法返回地址

- 存放调用该方法的pc寄存器的值。

- 一个方法的结束， 有两种方式：

  - 正常执行完成
  - 出现未处理的异常， 非正常退出

- 无论通过哪种方式退出， 在方法退出后都返回到该方法被调用的位置。 方法正常退出时， 调用者的pc寄存器的值作为返回地址， 即调用该方法（当前方法）的（上一级方法的）下一条指令的地址。 而通过异常退出的， 返回地址要通过异常表来确定， 栈帧中一般不会保存这部分信息。

- 当一个方法开始执行后，只有两种方式可以退出这个方法：

  1. 执行引擎遇到任意一个方法返回的字节码指令（return）， 会有返回值传递给上层的方法调用者， 简称正常完成出口；

     - 一个方法在正常调用完成之后究竟要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
     - 在字节码指令中， 返回指令包含ireturn（当返回值是boolean，short， byte， char， int类型时）， lreturn， freturn， dreturn以及areturn（引用类型）， 另外还有一个return指令工声明为void的方法， 实例初始化方法， 类和接口的初始化方法使用。

  2. 在方法执行过程中遇到了异常， 并且这个异常没有在方法内进行处理， 也就是只要在本方法的异常表中没有搜索到匹配的异常处理器， 就会导致方法退出。 简称异常完成出口。

     方法执行过程中抛出异常时的异常处理， 存储在一个异常处理表， 方便在发生异常的时候找到处理异常的代码。

